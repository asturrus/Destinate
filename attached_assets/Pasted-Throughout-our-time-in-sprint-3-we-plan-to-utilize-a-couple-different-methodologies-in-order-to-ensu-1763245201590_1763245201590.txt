Throughout our time in sprint 3 we plan to utilize a couple different methodologies in order to ensure our testing process is robust, optimal, and precise. Building upon what we have learned and created within Sprint 1 and 2 our unit tests have already been implemented and test the basic functionality of our components and ensure that they work in isolation. The tools we have utilized for this section have been mostly regarding Vitetest and the React Testing Library. As for our reasoning behind using these tools to test these specific components we believe it allows for fast feedback loops allowing us to test components quickly for rapid development. Moreover, the logic verification and component validation ensure that at a base level our functionality remains solidified prior to any edge case testing or boundary value analysis. The authentication flows and UI components need immediate verification to ensure that they are rendering without crashing. These unit tests allow us to catch 80% of bugs before they are pushed into production and potentially harm our product. This sprint we have the intention of properly testing for integration tests to ensure that components work together with state management and data flow as well as any potential API calls. The tools we will be utilizing within this type of testing will be parts of Vitetest as well as MSW (Mock Service Worker). This will be beneficial for Destinate as it will ensure the Supabase authentication integration as it will mock Supabase responses in order to test sign in page functionalities and flows to output proper results. Moreover, this will allow us to test that our critical integrations such as MapLibre GL and Supabase will be tested beyond their isolated components but rather the way they work together in unison without the actual simulation overhead of the End to End tests. Our end to end testing will be carried out through Playwright. This will be our most critical potential point of error therefore, we must ensure that it is of highest priority to produce positive results. The benefit of having these end to end tests integrated into Destinate is that it will allow us to replicate user flows and potential real world use cases that may be put into action. Moreover, some of these use cases may consist of browser specific behavior and multi-step workflows. The interactions and authentication flows can be complex therefore, leaving many steps for error. We believe that this was a better and more efficient way to iron out any bugs that may persist during production and development. The authentication flow for example, would ideally allow our user to click sign in -> fill out the form -> submit -> redirect the user to home. In order to track our build bugs and fixes essentially to keep a record of when bugs got fixed. These will be committed to github and contain a build number after configuration to our CI/CD pipeline. This will allow us to visualize what tests didnâ€™t pass and which build fixed those cases/bugs. Moreover, this will be a great record of how to fix these issues should similar situations arise in the future. Assuring that we have build identifications will give us full visibility into test results across individual builds as well as a way to control when they may have been fixed. 
